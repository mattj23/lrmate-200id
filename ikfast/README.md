# IKFast Kinematics

*IKFast* is a novel inverse kinematics solver written by Rosen Diankov as part of the OpenRAVE package.  It analytically solves the inverse kinematics equations of a robot and outputs highly optimized C++ files which compile into the solver.  It is hard to overstate how fast it is.  However, OpenRAVE is a low activity project and getting IKFast to run is often challenging. It also depends on Python 2.7 which has long since been deprecated.

Because of the difficulty of coaxing IKFast into compiling, this folder contains an IKFast module for the LRMate 200iD which I generated from the URDF using Cyberbotics' tooling.  The module consists of the following files:

* `ikfast.h` - a header file to include in any C++ program which you want to compile with the solver
* `ikfast_robot.cpp` - the source file generated by IKFast, include this in the C++ programs you want to compile with the solver
* `pyikfast.cpp` - a C++ source file which compiles to a set of python bindings which let the solver be used from within python.  I've never used this, so I'm not sure exactly how it works.
* `setup.py` - part of the module configuration for the python bindings, I've not used this so I don't know exactly how to make it work

The two files you'll need for a C++ program will be the `ikfast.h` and `ikfast_robot.cpp`.  

## Using IKFast in a C++ Program

The following is an example of C++ code using IKFast with Eigen (a header-only linear algebra library) for handling transforms.

```cpp
#include <vector>
#include <Eigen/Dense>
#include <Eigen/Geometry>

#include "ikfast.h"

using Transform = Eigen::Transform<double, 3, Eigen::Isometry>;  
using JointArray = std::array<double, 6>;

std::vector<JointArray> run_ik_fast(const Transform& target) {
    std::vector<JointArray> results;
    ikfast::IkSolutionList<double> solutions;

    double rotation[9];
    double translation[3];

    rotation[0] = target(0, 0);
    rotation[1] = target(0, 1);
    rotation[2] = target(0, 2);
    rotation[3] = target(1, 0);
    rotation[4] = target(1, 1);
    rotation[5] = target(1, 2);
    rotation[6] = target(2, 0);
    rotation[7] = target(2, 1);
    rotation[8] = target(2, 2);
    translation[0] = target(0, 3);
    translation[1] = target(1, 3);
    translation[2] = target(2, 3);

    bool success = ComputeIk(translation, rotation, nullptr, solutions);

    if (!success) {
        return results;
    }

    for (size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const auto &s = solutions.GetSolution(i);
        results.emplace_back();
        s.GetSolution(&results.back()[0], nullptr);
    }

    return results;
}
```

## Generating the IKFast Module

These are the steps I used to build the IKFast module.  They are here for reference, but the module is already generated, so generating it again is unnecessary unless you need to make changes to the robot.

Cyberbotics, the makers of the Webots simulation software, have built a [docker container which generates IKFast modules](https://github.com/cyberbotics/pyikfast) from URDF files.  I used this to sidestep the process of setting up an OpenRAVE environment.

On an x86-64 linux machine with docker installed, create a new folder and copy into it the files `urdf/urdf/LRMate-200iD.urdf` and `scripts/prep_urdf_for_ikfast.py`.  Then navigate into that folder.

```bash
# First, create the working version of the URDF and save it to a file named 'robot.urdf'
python3 prep_urdf_for_ikfast.py LRMate-200iD.urdf > robot.urdf

# Now launch the container
docker run -v $(pwd):/output cyberbotics/pyikfast Base J6 _lrmate200id
```

The completed files will be in the folder you're currently in.